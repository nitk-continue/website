from datetime import date
from typing import List, Union

from django.db import models


# Primary keys auto-generated by Django

class Tag(models.Model):
    """Represents a tag related to a post"""
    name = models.CharField(max_length=20)

    def __str__(self):
        return self.name

    def __repr__(self):
        return f'Tag(name={self.name})'

    # After creating the tag, ensure that save() is called before adding to Post
    @classmethod
    def create(cls, name: str = ''):
        return cls(name)


class Post(models.Model):
    """Represents an arbitrary post (may be Article or Blog)"""
    title = models.CharField(max_length=100)
    # By default, author is set to blank (indicating article)
    author = models.CharField(max_length=70, blank=True, default='', db_index=True)
    publish_date = models.DateField()
    # Enforcing max_length for TextField has no effect on DB storage
    content = models.TextField()
    # While accessing associated posts with Tag, use tag.posts.all()
    tags = models.ManyToManyField(Tag, db_table='PostTagRelation', related_name='posts')

    # Metadata for table
    class Meta:
        # Default ordering is descending order of publish_date, i.e., most recent posts first
        ordering = ['-publish_date']

    def __str__(self):
        return f'{self.title} by {self.author}'

    def __repr__(self):
        name = 'Article' if self.author == '' else 'Blog'
        return f'{name}(title={self.title}, author={self.author}, date={self.publish_date}, content={self.content}, ' \
               f'tags={self.tags})'

    @classmethod
    def create(cls, title: str = '', author: str = '', publish_date: date = date.today(), content: str = '',
               tags: Union[List[Tag], None] = None):
        # Tags may be a list of 'Tag' or NoneType
        if tags is None:
            tags = []
        return cls(title, author, publish_date, content, tags)
